<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Inbox Puzzles â€” Sudoku 9Ã—9 (Validation)</title>
<style>
  :root {
    --teal: #1f9dbf;
    --gold: #f5b041;
    --bg: #faf9f6;
    --card: #fff;
    --error: #ffb3b3;
  }
  html, body {
    margin: 0; padding: 0;
    background: var(--bg);
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    display: flex; justify-content: center; align-items: flex-start;
    min-height: 100vh; box-sizing: border-box;
  }

  .container {
    width: 100%; max-width: 620px; margin: 0.6em;
    background: var(--card);
    border-radius: 12px;
    padding: 0.9em;
    box-shadow: 0 3px 10px rgba(0,0,0,0.05);
    box-sizing: border-box; overflow: hidden;
  }

  .title {
    text-align: center; color: var(--teal);
    font-size: clamp(1.1rem, 4vw, 1.45rem);
    margin: 0 0 0.2rem 0; font-weight: 700;
  }
  .tag {
    text-align: center; color: #666;
    margin: 0 0 0.5rem 0; font-style: italic;
    font-size: clamp(0.85rem, 3vw, 1rem);
  }

  .grid-wrap {
    display: flex; justify-content: center;
    width: 100%; overflow: hidden;
  }

  .sudoku-grid {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    gap: 1.4vw;
    width: min(95vw, 560px);
    max-width: 560px;
    padding: 0.4rem;
    box-sizing: border-box;
  }

  .cell {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
  }

  .cell input, .cell .given {
    width: calc((min(95vw, 560px) - 8 * 1.4vw - 1rem) / 9);
    height: calc((min(95vw, 560px) - 8 * 1.4vw - 1rem) / 9);
    font-size: clamp(16px, 4.2vw, 20px);
    text-align: center; border-radius: 8px;
    border: 1.3px solid #ccc;
    font-family: monospace; font-weight: 700;
    box-sizing: border-box; -webkit-appearance: none;
  }

  .cell .given {
    background: #f2f7f7; color: #0b3b3b;
    display: flex; align-items: center; justify-content: center;
    pointer-events: none;
  }

  .cell input:focus { outline: none; border-color: var(--teal); background: #e8f8fb; }

  /* conflict visuals */
  .cell input.conflict {
    background: var(--error) !important;
    border-color: #e60000 !important;
    color: #800;
  }

  .status {
    text-align: center;
    margin-top: 0.4rem;
    color: #444;
    font-size: 0.95rem;
  }

  .controls {
    text-align: center; margin-top: 0.9rem;
  }
  .controls button {
    padding: 9px 14px; border-radius: 8px; border: none;
    cursor: pointer; background: var(--gold);
    color: #222; font-weight: 700;
    font-size: clamp(14px, 3vw, 15px);
  }
  .controls button:hover { background: #d9951f; color: #fff; }
</style>
</head>
<body>
  <main class="container" role="main" aria-label="Sudoku puzzle">
    <h1 class="title">Daily Sudoku â€” 9Ã—9</h1>
    <p class="tag">Type digits (1â€“9). Conflicts highlight in red. Progress saves automatically.</p>

    <div class="grid-wrap">
      <div id="sudoku" class="sudoku-grid" aria-live="polite"></div>
    </div>

    <div class="status" id="status">Conflicts: 0</div>

    <div class="controls">
      <button id="clearBtn" aria-label="Clear my answers">ðŸ”„ Clear My Answers</button>
    </div>
  </main>

<script>
(function(){
  // puzzle (0 = blank)
  const puzzle = [
    [0,0,0,0,5,1,4,0,3],
    [0,3,4,8,9,0,0,0,6],
    [0,0,2,6,0,3,0,1,8],
    [0,0,3,1,0,0,0,0,0],
    [8,6,0,3,2,0,0,0,1],
    [0,0,1,7,0,0,0,0,0],
    [3,0,8,9,7,2,5,6,0],
    [5,2,7,4,3,0,0,0,9],
    [0,9,0,0,0,8,3,2,7]
  ];

  const STORAGE_KEY = "sudoku-9x9-progress-v3";
  const CLEAR_FLAG = "sudoku-9x9-cleared-v3";
  const gridEl = document.getElementById('sudoku');
  const clearBtn = document.getElementById('clearBtn');
  const statusEl = document.getElementById('status');

  // cookie helpers
  function setCookie(name,value,days){
    const d=new Date(); d.setTime(d.getTime()+(days*24*60*60*1000));
    document.cookie = name+"="+encodeURIComponent(value)+";expires="+d.toUTCString()+";path=/";
  }
  function getCookie(name){
    const m=document.cookie.match(new RegExp('(^|; )'+name+'=([^;]*)'));
    return m?decodeURIComponent(m[2]):"";
  }

  // load saved unless cleared
  const isCleared = getCookie(CLEAR_FLAG) === "true";
  let saved = {};
  try {
    if(!isCleared){
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw) saved = JSON.parse(raw);
    }
  } catch(e){ saved = {}; }

  // structured storage for inputs: cells[r][c] = input element or null
  const cells = Array.from({length:9}, ()=>Array(9).fill(null));

  // helper id
  function idFor(r,c){ return `${r}-${c}`; }

  // build grid
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const cellWrap = document.createElement('div');
      cellWrap.className = 'cell';

      const val = puzzle[r][c];
      if(val === 0){
        const inp = document.createElement('input');
        inp.inputMode = 'numeric';
        inp.pattern = '[1-9]';
        inp.maxLength = 1;
        inp.dataset.row = r;
        inp.dataset.col = c;

        const key = idFor(r,c);
        if(saved && saved[key]) inp.value = saved[key];

        // input handler
        inp.addEventListener('input', (e) => {
          const v = e.target.value.replace(/[^1-9]/g,'').slice(0,1);
          e.target.value = v;
          if(v) saved[key] = v; else delete saved[key];
          try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(saved)); } catch(err){}
          // reset cleared cookie so subsequent loads restore
          setCookie(CLEAR_FLAG, "false", 7);
          validateGrid();
        });

        // paste guard
        inp.addEventListener('paste', (ev) => {
          ev.preventDefault();
          const txt = (ev.clipboardData || window.clipboardData).getData('text') || '';
          const digit = txt.replace(/[^1-9]/g,'').slice(0,1);
          if(digit){ inp.value = digit; inp.dispatchEvent(new Event('input')); }
        });

        cellWrap.appendChild(inp);
        cells[r][c] = inp;
      } else {
        const span = document.createElement('div');
        span.className = 'given';
        span.textContent = val;
        cellWrap.appendChild(span);
        cells[r][c] = null;
      }
      gridEl.appendChild(cellWrap);
    }
  }

  // Clear answers
  clearBtn.addEventListener('click', () => {
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const el = cells[r][c];
        if(el) el.value = '';
      }
    }
    try{ localStorage.removeItem(STORAGE_KEY); } catch(e){}
    setCookie(CLEAR_FLAG, "true", 7);
    validateGrid();
  });

  // validation
  function validateGrid(){
    // clear previous conflict marks (class and inline style)
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const el = cells[r][c];
        if(el){
          el.classList.remove('conflict');
          el.style.background = '';
          el.style.borderColor = '';
          el.style.color = '';
        }
      }
    }

    const grid = Array.from({length:9}, ()=>Array(9).fill(0));
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const el = cells[r][c];
        if(el && el.value) grid[r][c] = parseInt(el.value,10) || 0;
      }
    }

    let conflictCount = 0;

    function mark(r,c){
      const el = cells[r][c];
      if(!el) return;
      // apply class + inline style (inline style as a guaranteed visual fallback)
      if(!el.classList.contains('conflict')) {
        el.classList.add('conflict');
        el.style.background = 'var(--error)';
        el.style.borderColor = '#e60000';
        el.style.color = '#800';
        conflictCount++;
      }
    }

    // rows
    for(let r=0;r<9;r++){
      const seen = {};
      for(let c=0;c<9;c++){
        const v = grid[r][c];
        if(!v) continue;
        if(seen[v]===undefined) seen[v] = c;
        else {
          // mark both positions
          mark(r,c);
          mark(r,seen[v]);
        }
      }
    }

    // columns
    for(let c=0;c<9;c++){
      const seen = {};
      for(let r=0;r<9;r++){
        const v = grid[r][c];
        if(!v) continue;
        if(seen[v]===undefined) seen[v] = r;
        else {
          mark(r,c);
          mark(seen[v],c);
        }
      }
    }

    // boxes
    for(let br=0;br<3;br++){
      for(let bc=0;bc<3;bc++){
        const seen = {};
        for(let r=br*3;r<br*3+3;r++){
          for(let c=bc*3;c<bc*3+3;c++){
            const v = grid[r][c];
            if(!v) continue;
            if(seen[v]===undefined) seen[v] = {r,c};
            else {
              mark(r,c);
              mark(seen[v].r, seen[v].c);
            }
          }
        }
      }
    }

    statusEl.textContent = `Conflicts: ${conflictCount}`;
  }

  // run initial validation (in case saved state has conflicts)
  setTimeout(validateGrid, 120);

  // expose validateGrid for debugging (optional)
  window.__sudokuValidate = validateGrid;
})();
</script>
</body>
</html>
